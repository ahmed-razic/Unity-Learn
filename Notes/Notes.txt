To save changes in Projects settings save the project by going to File > Save Project

To add sprite renderer to game object, create empty game object and add spriterenderer component

Background music is added to the main camera

To add sounds to Player first add AudioSource component, Audio clips. sjort audio clips are played using PlayOneShot()

To make camera rotate around certain point, make empty game object at that point and camera as a child of that empty object. 
When Empty object rotates around itself it will rotate camera as well, because child moves with its parent.

OnCollisionEnter() is used when there is a need to do something with the physics

IEnumerator FunctionName() { yield return new WaitForSeconds(7); doSomething; } doSomething is activated after 7 seconds. This is called using StartCoroutine(FunctionName())



You can move the camera to align with your current Scene view by selecting it in the Hierarchy window and then pressing Ctrl+Shift+F.

To change a GameObject back to white, apply the material named Default-Material under the “Mesh Renderer” component.

To apply image/texture to a material - In the Inspector window, select the object picker (circle icon) next to the Albedo property and select the Herringbone texture file that you imported. 
Select Texture window with the Herringbone image file selected.The image is now applied to the material as the Albedo map (or Base map) and will appear in the Material preview in the Inspector.

To get first child of GameObject
	child = transform.GetChild(0).gameObject;

To reset player position
    void ResetPlayerPosition ()
    {
        player.transform.position = new Vector3(0, 1, -7);
        player.GetComponent<Rigidbody>().velocity = Vector3.zero;
        player.GetComponent<Rigidbody>().angularVelocity = Vector3.zero;

    }

Canvas holds all UI elements (buttons, text,...)

using directive is used for importing other libraries into a current script

To add function to an OnClick event for Button, drag script with that function to OnClick field in Button properties, then select appropriate function from that class.

To make changes to a button, make a reference in game manager script

To add prefab to other prefab, open prefab editor for parent and drag into it child prefab. This is usefull when having large nested prefabs or changing simple game objects with final characters. 
Then add box collider or rigid body to a child character prefab. To remove parent prefab, select it and then uncheck mesh renderer component and its collider.



The GameObjects in 2D Scenes are called Sprites. Sprites are typically imported images with specific properties that allow them to be used as interactive 2D GameObjects.

Unity uses a Y-up coordinate system, which applies in 2D as well as 3D. Y is up, and Z is toward and away from the player’s point of view. 
Therefore, changes to scale in the Z direction are not visible to the player. Changes to position in Z will place Sprites behind or in front of one another

In the Hierarchy window, right-click and select 2D Object > Sprite > Circle to create an empty Sprite that will act as a placeholder.  
At this point, you can’t see the Sprite in Scene View, but it will become visible once you assign an image to it.

For the Sprite you created from an image, you must add the collider yourself.

The RigidBody 2D Component also gives a Sprite physical properties, so what is the difference? RigidBody properties control how the GameObject interacts with gravity and air density. 
For example, the RigidBody properties on the Circle Sprite make it fall, but when it hits another GameObject, it will pass through it. The Collider Component adds additional properties 
that determine how objects interact with each other. By adding a Collider Component to the Circle and a Sprite below it to represent the ground, the Circle will stop its downward trajectory when it reaches the ground.



Access attributes: public, private, protected, static, const, readonly

public - can be accessed from instance, other classes instances and Unity editor
private - can be accessed only in instance
protected - can be accessed from class instance or instances of inherited classes. Can be private
static - can be accesed from anywhere but not through an instance. Instead, it's referenced through the type name. Must be public to be accessed.
const - constant value must be declared during declaration
readonly - can be declared without value, and only change once during first initialization in Constructor, init-only setter of the type in which the field is defined or a variable initializator.

ALL VARIABLES/METHODS ARE PRIVATE BY DEFAULT IN A CLASS.

Event functions: Awake(), Start(), FixedUpdate(), Update(), LateUpdate()

Start is called only once at the very start of the game when certain object must do something as soon as game starts.
Awake is called when game object is first called.
FixedUpdate is used when you have movement and physics, it is called before Update.
Update is usefull for userInputs.
LateUpdate is usefull for camera update because it is called when all calculations are done so that we can have fluid movement. It is usefull for following of player.

FixedUpdate, Update and LateUpdate are called continously in that order.




AddRelativeForce() adds force to a rigidbody relative to its coordinate system.

To use math in unity, use Mathf library.

If function accepts only string argument, then a number can be implicitly convered to text if used with string literals 
SomeFunction.SetText("Speed: " + speed + " kph")

Application.Quit only works in the built application, not when you’re testing in the Editor. To make it work similarly there, you’ll need to use a special method to stop PlayMode. 

All lines starting with # aren’t really “code”. They won’t be compiled and executed — they’re actually instructions for the compiler. 


#if UNITY_EDITOR
using UnityEditor;
#endif
You’ve added conditional instructions to the compiler around the namespace: #if UNITY_EDITOR, so that the namespace will only be included when you are compiling within the Unity Editor.


DontDestroyOnLoad: A method in Unity that marks a GameObject to be saved in memory even when loading or unloading a new scene.DontDestroyOnLoad: A method in Unity that marks a GameObject to be saved in memory even when loading or unloading a new scene.

Static classes and class members: Static class members can be accessed from anywhere without having to reference a specific object. You may already have used some of these, such as Time.deltaTime or Vector3.forward. Those aren’t a specific time object or a specific vector3 — the format for static class members is ClassName.memberName.

singleton. You use it to ensure that only a single instance of the Object can ever exist, so it acts as a central point of access.

The process of converting complex data into a format in which it can be stored is called serialization. When you’re ready to access the data again, the process of converting it back is called deserialization. 
Flow diagram shows the process of serialization: an object being converted to bytes and then stored; the deserialization process shows this in reverse.
There are different formats that you can use to store data, depending on what the data is and what you want to do with it. In this case, you’re going to use the JSON format. JSON is a text format used to store data and exchange it between platforms. It was first developed for the web, and its full name is  JavaScript Object Notation. The JSON format stores data in the form of a key:value pair. The key is a string, and the value can be:a number, a string, a Boolean (true/false), an array of values, another JSON object. 
{
  "name": "John",
  "age": 27,
  "address": {
    "streetAddress": "21 2nd Street",
    "city": "New York"
  }
  "pet": [“dog”, “cat”]
}


string json = JsonUtility.ToJson(myData); - To serialize
PlayerData myData = JsonUtility.FromJson<PlayerData>(json); - To deserialize


JsonUtility doesn’t work on primitive types, arrays, lists, or dictionaries. 
As you might expect, JsonUtility only works on the Serializable type — MonoBehaviour or the other classes/structs you write onto which you can add the [Serializable] attribute.

Why are you creating a class and not giving the MainManager instance directly to the JsonUtility? Well, most of the time you won’t save everything inside your classes. It’s good practice and more efficient to use a small class that only contains the specific data that you want to save


